// Generated by CoffeeScript 1.7.1
(function() {
  var Creator, Fs, Hubot, OptParse, Options, Parser, Path, Switches, adapterPath, creator, loadScripts, robot;

  Creator = require('../src/creator');

  Hubot = require('..');

  Fs = require('fs');

  OptParse = require('optparse');

  Path = require('path');

  Switches = [["-a", "--adapter ADAPTER", "The Adapter to use"], ["-c", "--create PATH", "Create a deployable hubot"], ["-d", "--disable-httpd", "Disable the HTTP server"], ["-h", "--help", "Display the help information"], ["-l", "--alias ALIAS", "Enable replacing the robot's name with alias"], ["-n", "--name NAME", "The name of the robot in chat"], ["-r", "--require PATH", "Alternative scripts path"], ["-v", "--version", "Displays the version of hubot installed"]];

  Options = {
    adapter: process.env.HUBOT_ADAPTER || "shell",
    alias: process.env.HUBOT_ALIAS || false,
    create: process.env.HUBOT_CREATE || false,
    enableHttpd: process.env.HUBOT_HTTPD || true,
    scripts: process.env.HUBOT_SCRIPTS || [],
    name: process.env.HUBOT_NAME || "Hubot",
    path: process.env.HUBOT_PATH || "."
  };

  Parser = new OptParse.OptionParser(Switches);

  Parser.banner = "Usage hubot [options]";

  Parser.on("adapter", function(opt, value) {
    return Options.adapter = value;
  });

  Parser.on("create", function(opt, value) {
    Options.path = value;
    return Options.create = true;
  });

  Parser.on("disable-httpd", function(opt) {
    return Options.enableHttpd = false;
  });

  Parser.on("help", function(opt, value) {
    console.log(Parser.toString());
    return process.exit(0);
  });

  Parser.on("alias", function(opt, value) {
    value || (value = '/');
    return Options.alias = value;
  });

  Parser.on("name", function(opt, value) {
    return Options.name = value;
  });

  Parser.on("require", function(opt, value) {
    return Options.scripts.push(value);
  });

  Parser.on("version", function(opt, value) {
    return Options.version = true;
  });

  Parser.parse(process.argv);

  if (process.platform !== "win32") {
    process.on('SIGTERM', function() {
      return process.exit(0);
    });
  }

  if (Options.create) {
    creator = new Creator(Options.path);
    creator.run();
  } else {
    adapterPath = Path.join(__dirname, "..", "src", "adapters");
    robot = Hubot.loadBot(adapterPath, Options.adapter, Options.enableHttpd, Options.name);
    if (Options.version) {
      console.log(robot.version);
      process.exit(0);
    }
    robot.alias = Options.alias;
    loadScripts = function() {
      var externalScripts, hubotScripts, path, scriptsPath, _i, _len, _ref, _results;
      scriptsPath = Path.resolve(".", "scripts");
      robot.load(scriptsPath);
      scriptsPath = Path.resolve(".", "src", "scripts");
      robot.load(scriptsPath);
      hubotScripts = Path.resolve(".", "hubot-scripts.json");
      Fs.exists(hubotScripts, function(exists) {
        if (exists) {
          return Fs.readFile(hubotScripts, function(err, data) {
            var scripts;
            if (data.length > 0) {
              try {
                scripts = JSON.parse(data);
                scriptsPath = Path.resolve("node_modules", "hubot-scripts", "src", "scripts");
                return robot.loadHubotScripts(scriptsPath, scripts);
              } catch (_error) {
                err = _error;
                console.error("Error parsing JSON data from hubot-scripts.json: " + err);
                return process.exit(1);
              }
            }
          });
        }
      });
      externalScripts = Path.resolve(".", "external-scripts.json");
      Fs.exists(externalScripts, function(exists) {
        if (exists) {
          return Fs.readFile(externalScripts, function(err, data) {
            var scripts;
            if (data.length > 0) {
              try {
                scripts = JSON.parse(data);
              } catch (_error) {
                err = _error;
                console.error("Error parsing JSON data from external-scripts.json: " + err);
                process.exit(1);
              }
              return robot.loadExternalScripts(scripts);
            }
          });
        }
      });
      _ref = Options.scripts;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        path = _ref[_i];
        if (path[0] === '/') {
          scriptsPath = path;
        } else {
          scriptsPath = Path.resolve(".", path);
        }
        _results.push(robot.load(scriptsPath));
      }
      return _results;
    };
    robot.adapter.on('connected', loadScripts);
    robot.run();
  }

}).call(this);

//# sourceMappingURL=hubot.map
