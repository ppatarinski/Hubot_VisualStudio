// Generated by CoffeeScript 1.7.1
(function() {
  var Adapter, Readline, Robot, Shell, TextMessage,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  Readline = require('readline');

  Robot = require('../robot');

  Adapter = require('../adapter');

  TextMessage = require('../message').TextMessage;

  Shell = (function(_super) {
    __extends(Shell, _super);

    function Shell() {
      return Shell.__super__.constructor.apply(this, arguments);
    }

    Shell.prototype.send = function() {
      var envelope, str, strings, _i, _j, _len, _len1;
      envelope = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (process.platform !== 'win32') {
        for (_i = 0, _len = strings.length; _i < _len; _i++) {
          str = strings[_i];
          console.log("\x1b[01;32m" + str + "\x1b[0m");
        }
      } else {
        for (_j = 0, _len1 = strings.length; _j < _len1; _j++) {
          str = strings[_j];
          console.log("" + str);
        }
      }
      return this.repl.prompt();
    };

    Shell.prototype.emote = function() {
      var envelope, str, strings, _i, _len, _results;
      envelope = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      _results = [];
      for (_i = 0, _len = strings.length; _i < _len; _i++) {
        str = strings[_i];
        _results.push(this.send(envelope, "* " + str));
      }
      return _results;
    };

    Shell.prototype.reply = function() {
      var envelope, strings;
      envelope = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      strings = strings.map(function(s) {
        return "" + envelope.user.name + ": " + s;
      });
      return this.send.apply(this, [envelope].concat(__slice.call(strings)));
    };

    Shell.prototype.run = function() {
      var self, stdin, stdout;
      self = this;
      stdin = process.openStdin();
      stdout = process.stdout;
      process.on('uncaughtException', (function(_this) {
        return function(err) {
          return _this.robot.logger.error(err.stack);
        };
      })(this));
      this.repl = Readline.createInterface(stdin, stdout, null);
      this.repl.on('close', (function(_this) {
        return function() {
          stdin.destroy();
          _this.robot.shutdown();
          return process.exit(0);
        };
      })(this));
      this.repl.on('line', (function(_this) {
        return function(buffer) {
          var user;
          if (buffer.toLowerCase() === 'exit') {
            _this.repl.close();
          }
          _this.repl.prompt();
          user = _this.robot.brain.userForId('1', {
            name: 'Shell',
            room: 'Shell'
          });
          return _this.receive(new TextMessage(user, buffer, 'messageId'));
        };
      })(this));
      self.emit('connected');
      this.repl.setPrompt("" + this.robot.name + "> ");
      return this.repl.prompt();
    };

    return Shell;

  })(Adapter);

  exports.use = function(robot) {
    return new Shell(robot);
  };

}).call(this);

//# sourceMappingURL=shell.map
